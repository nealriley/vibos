<!DOCTYPE html>
<!--
  VibeOS Custom noVNC Interface (beta.html)
  
  A custom-branded VNC web client built on the noVNC RFB library.
  This replaces the default vnc.html with a cleaner, VibeOS-themed interface.
  
  Features:
    - Auto-connect on page load (no connection dialog)
    - Scaled viewport (VNC canvas fits browser window)
    - Dark theme matching shell-ui aesthetic
    - VibeOS branding (logo, title)
    - Connection status indicator (green/yellow/red dot)
    - Auto-reconnect on disconnect (3s interval, max 50 attempts)
    - Fullscreen mode (button + F11 keyboard shortcut)
    - Ctrl+Alt+Del button for VM control
    - Reconnect overlay with manual retry option
  
  URL Parameters:
    ?host=<hostname>     VNC host (default: current hostname)
    ?port=<port>         VNC port (default: current port, typically 6080)
    ?path=<path>         WebSocket path (default: 'websockify')
    ?password=<pwd>      VNC password (if server requires auth)
    ?resize=true         Request server to resize to match viewport
    ?view_only=true      View-only mode (no input sent to server)
  
  Access: http://localhost:6080/beta.html
  
  Based on: noVNC vnc_lite.html (minimal reference implementation)
  noVNC Project: https://github.com/novnc/noVNC
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VibeOS</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23667eea' rx='20' width='100' height='100'/><text x='50' y='72' font-size='60' font-family='system-ui' font-weight='bold' fill='white' text-anchor='middle'>V</text></svg>">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-color: #0a0a0a;
            --surface-color: #1a1a1a;
            --border-color: #333;
            --text-color: #e0e0e0;
            --text-muted: #888;
            --accent-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --success-color: #22c55e;
            --warning-color: #f59e0b;
            --error-color: #ef4444;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background: var(--bg-color);
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        /* Top Bar */
        #top_bar {
            height: 36px;
            background: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 12px;
            flex-shrink: 0;
            z-index: 100;
        }

        body.fullscreen #top_bar {
            display: none;
        }

        #logo {
            width: 24px;
            height: 24px;
            background: var(--accent-gradient);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 14px;
            flex-shrink: 0;
        }

        #title {
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 4px;
            color: var(--text-color);
            text-transform: uppercase;
            opacity: 0.9;
        }

        #spacer {
            flex: 1;
        }

        #status {
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #status_dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning-color);
            transition: background-color 0.3s ease;
        }

        #status_dot.connected {
            background: var(--success-color);
        }

        #status_dot.disconnected {
            background: var(--error-color);
        }

        #status_dot.connecting {
            background: var(--warning-color);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        #buttons {
            display: flex;
            gap: 4px;
        }

        .toolbar_btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
        }

        .toolbar_btn:hover {
            background: var(--border-color);
            color: var(--text-color);
        }

        .toolbar_btn:active {
            transform: scale(0.95);
        }

        .toolbar_btn.recording {
            background: #dc2626;
            border-color: #dc2626;
            color: white;
            animation: pulse-recording 1s infinite;
        }

        @keyframes pulse-recording {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Command Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal.hidden {
            display: none;
        }

        .modal_content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .modal_header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 500;
        }

        .modal_close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 20px;
            cursor: pointer;
            padding: 0 4px;
        }

        .modal_close:hover {
            color: var(--text-color);
        }

        .modal_body {
            display: flex;
            gap: 8px;
            padding: 16px;
        }

        #cmd_input {
            flex: 1;
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px 12px;
            color: var(--text-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        #cmd_input:focus {
            outline: none;
            border-color: #667eea;
        }

        .modal_btn {
            background: var(--accent-gradient);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
        }

        .modal_btn:hover {
            opacity: 0.9;
        }

        .modal_btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modal_output_wrapper {
            position: relative;
            margin: 0 16px 16px;
            flex: 1;
            min-height: 150px;
            max-height: 400px;
        }

        #cmd_output {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin: 0;
            color: var(--text-color);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            line-height: 1.5;
            overflow: auto;
            height: 100%;
            min-height: 150px;
            max-height: 400px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .modal_copy {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }

        .modal_copy:hover {
            background: var(--border-color);
            color: var(--text-color);
        }

        /* VNC Screen */
        #screen {
            flex: 1;
            overflow: hidden;
            background: var(--bg-color);
        }

        /* Reconnect Overlay */
        #reconnect_overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 10, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        #reconnect_overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .overlay_content {
            text-align: center;
            color: var(--text-color);
        }

        .overlay_logo {
            width: 64px;
            height: 64px;
            background: var(--accent-gradient);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 32px;
            margin: 0 auto 24px;
        }

        .overlay_status {
            font-size: 18px;
            font-weight: 300;
            margin-bottom: 8px;
        }

        .overlay_message {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 24px;
        }

        .spinner {
            display: flex;
            gap: 6px;
            justify-content: center;
            margin-bottom: 24px;
        }

        .spinner_dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            animation: bounce 1.4s ease-in-out infinite both;
        }

        .spinner_dot:nth-child(1) { animation-delay: -0.32s; }
        .spinner_dot:nth-child(2) { animation-delay: -0.16s; }
        .spinner_dot:nth-child(3) { animation-delay: 0s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        .overlay_btn {
            background: var(--accent-gradient);
            border: none;
            color: white;
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
        }

        .overlay_btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4);
        }

        .overlay_btn:active {
            transform: scale(0.98);
        }

        /* Error state */
        .overlay_content.error .overlay_logo {
            background: var(--error-color);
        }
    </style>

    <script type="module">
        // ====================================================================
        // VibeOS VNC Client
        // Uses noVNC's RFB (Remote Frame Buffer) library for VNC protocol
        // ====================================================================
        
        import RFB from './core/rfb.js';

        // ====================================================================
        // State Management
        // ====================================================================
        let rfb = null;  // RFB connection instance
        let reconnectTimer = null;
        
        // Screen recording state
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let reconnectAttempts = 0;
        const RECONNECT_DELAY = 3000;
        const MAX_RECONNECT_ATTEMPTS = 50;

        // DOM Elements
        const screenEl = document.getElementById('screen');
        const statusDot = document.getElementById('status_dot');
        const statusText = document.getElementById('status_text');
        const overlay = document.getElementById('reconnect_overlay');
        const overlayStatus = document.getElementById('overlay_status');
        const overlayMessage = document.getElementById('overlay_message');
        const overlayContent = document.querySelector('.overlay_content');
        const retryBtn = document.getElementById('retry_btn');
        const fullscreenBtn = document.getElementById('fullscreen_btn');
        const ctrlAltDelBtn = document.getElementById('cad_btn');

        // Read URL parameters
        function getParam(name, defaultValue) {
            const re = new RegExp('.*[?&#]' + name + '=([^&#]*)');
            const match = (document.location.href + window.location.hash).match(re);
            return match ? decodeURIComponent(match[1]) : defaultValue;
        }

        // Build WebSocket URL
        function buildWebSocketUrl() {
            const host = getParam('host', window.location.hostname);
            const port = getParam('port', window.location.port);
            const path = getParam('path', 'websockify');
            
            let url = window.location.protocol === 'https:' ? 'wss' : 'ws';
            url += '://' + host;
            if (port) url += ':' + port;
            url += '/' + path;
            
            return url;
        }

        // Update UI status
        function setStatus(state, message) {
            statusDot.className = state;
            statusText.textContent = message || state.charAt(0).toUpperCase() + state.slice(1);
        }

        // Show/hide reconnect overlay
        function showOverlay(status, message, isError = false) {
            overlayStatus.textContent = status;
            overlayMessage.textContent = message;
            overlayContent.classList.toggle('error', isError);
            overlay.classList.remove('hidden');
        }

        function hideOverlay() {
            overlay.classList.add('hidden');
        }

        // Connection handlers
        function onConnect() {
            setStatus('connected', 'Connected');
            hideOverlay();
            reconnectAttempts = 0;
            cancelReconnect();
        }

        function onDisconnect(e) {
            rfb = null;
            
            if (e.detail.clean) {
                setStatus('disconnected', 'Disconnected');
                showOverlay('Disconnected', 'Connection closed cleanly. Reconnecting...');
            } else {
                setStatus('disconnected', 'Connection Lost');
                showOverlay('Connection Lost', 'Attempting to reconnect...');
            }
            
            scheduleReconnect();
        }

        function onCredentialsRequired(e) {
            const password = prompt('VNC Password Required:');
            if (password) {
                rfb.sendCredentials({ password: password });
            }
        }

        function onSecurityFailure(e) {
            setStatus('disconnected', 'Auth Failed');
            showOverlay('Authentication Failed', e.detail.reason || 'Invalid credentials', true);
            cancelReconnect();
        }

        // Connect to VNC
        function connect() {
            if (rfb) {
                rfb.disconnect();
                rfb = null;
            }

            setStatus('connecting', 'Connecting...');
            
            const url = buildWebSocketUrl();
            const password = getParam('password', '');

            try {
                rfb = new RFB(screenEl, url, {
                    credentials: password ? { password: password } : undefined
                });

                // Configure
                rfb.scaleViewport = true;
                rfb.resizeSession = getParam('resize', 'false') === 'true';
                rfb.viewOnly = getParam('view_only', 'false') === 'true';

                // Events
                rfb.addEventListener('connect', onConnect);
                rfb.addEventListener('disconnect', onDisconnect);
                rfb.addEventListener('credentialsrequired', onCredentialsRequired);
                rfb.addEventListener('securityfailure', onSecurityFailure);

            } catch (err) {
                console.error('Connection error:', err);
                setStatus('disconnected', 'Error');
                showOverlay('Connection Error', err.message, true);
                scheduleReconnect();
            }
        }

        // Reconnect logic
        function scheduleReconnect() {
            cancelReconnect();
            
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                showOverlay('Connection Failed', 'Max reconnect attempts reached. Click to retry.', true);
                return;
            }
            
            reconnectAttempts++;
            overlayMessage.textContent = `Reconnecting in ${RECONNECT_DELAY/1000}s... (attempt ${reconnectAttempts})`;
            
            reconnectTimer = setTimeout(() => {
                overlayMessage.textContent = 'Connecting...';
                connect();
            }, RECONNECT_DELAY);
        }

        function cancelReconnect() {
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }
        }

        // Manual retry
        function retryNow() {
            cancelReconnect();
            reconnectAttempts = 0;
            overlayMessage.textContent = 'Connecting...';
            connect();
        }

        // Fullscreen toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    document.body.classList.add('fullscreen');
                }).catch(err => {
                    console.warn('Fullscreen failed:', err);
                });
            } else {
                document.exitFullscreen().then(() => {
                    document.body.classList.remove('fullscreen');
                });
            }
        }

        // Handle fullscreen change from Escape key
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                document.body.classList.remove('fullscreen');
            }
        });

        // Send Ctrl+Alt+Del
        function sendCtrlAltDel() {
            if (rfb) {
                rfb.sendCtrlAltDel();
            }
        }

        // Screenshot - capture canvas as PNG
        function takeScreenshot() {
            if (!rfb) return;
            
            // Get the canvas from RFB
            const canvas = screenEl.querySelector('canvas');
            if (!canvas) {
                alert('No canvas found - VNC not connected');
                return;
            }
            
            try {
                // Convert canvas to data URL
                const dataUrl = canvas.toDataURL('image/png');
                
                // Create download link
                const link = document.createElement('a');
                link.download = `vibeos-screenshot-${Date.now()}.png`;
                link.href = dataUrl;
                link.click();
                
                // Visual feedback
                const btn = document.getElementById('screenshot_btn');
                const originalText = btn.textContent;
                btn.textContent = 'Saved!';
                setTimeout(() => { btn.textContent = originalText; }, 1000);
            } catch (err) {
                console.error('Screenshot failed:', err);
                alert('Screenshot failed: ' + err.message);
            }
        }
        
        // Screen Recording - toggle recording on/off
        function toggleRecording() {
            const btn = document.getElementById('record_btn');
            
            if (!isRecording) {
                // Start recording
                const canvas = screenEl.querySelector('canvas');
                if (!canvas) {
                    alert('No canvas found - VNC not connected');
                    return;
                }
                
                try {
                    // Capture stream from canvas at 30fps
                    const stream = canvas.captureStream(30);
                    
                    // Create MediaRecorder with webm format
                    const options = { mimeType: 'video/webm;codecs=vp9' };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm';
                    }
                    
                    mediaRecorder = new MediaRecorder(stream, options);
                    recordedChunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            recordedChunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        // Create blob and download
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = `vibeos-recording-${Date.now()}.webm`;
                        link.href = url;
                        link.click();
                        URL.revokeObjectURL(url);
                        
                        // Reset state
                        recordedChunks = [];
                        mediaRecorder = null;
                    };
                    
                    mediaRecorder.start(1000); // Collect data every second
                    isRecording = true;
                    btn.textContent = 'Stop Rec';
                    btn.classList.add('recording');
                    
                } catch (err) {
                    console.error('Recording failed:', err);
                    alert('Recording failed: ' + err.message);
                }
            } else {
                // Stop recording
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                isRecording = false;
                btn.textContent = 'Record';
                btn.classList.remove('recording');
            }
        }
        
        // Send Alt+Tab
        function sendAltTab() {
            if (rfb) {
                // KeySyms: Alt_L=0xffe9, Tab=0xff09
                rfb.sendKey(0xffe9, 'Alt_L', true);   // Alt down
                rfb.sendKey(0xff09, 'Tab', true);    // Tab down
                rfb.sendKey(0xff09, 'Tab', false);   // Tab up
                rfb.sendKey(0xffe9, 'Alt_L', false); // Alt up
            }
        }
        
        // Send Super (Windows) key
        function sendSuper() {
            if (rfb) {
                // KeySym: Super_L=0xffeb
                rfb.sendKey(0xffeb, 'Super_L', true);  // Super down
                rfb.sendKey(0xffeb, 'Super_L', false); // Super up
            }
        }

        // Command Modal - execute commands via OpenCode API
        const cmdModal = document.getElementById('cmd_modal');
        const cmdInput = document.getElementById('cmd_input');
        const cmdOutput = document.getElementById('cmd_output');
        const cmdSessionId = { current: null };
        
        function openCmdModal() {
            cmdModal.classList.remove('hidden');
            cmdInput.value = '';
            cmdOutput.textContent = 'Enter a command and click Run';
            cmdInput.focus();
        }
        
        function closeCmdModal() {
            cmdModal.classList.add('hidden');
        }
        
        async function runCommand() {
            const command = cmdInput.value.trim();
            if (!command) return;
            
            const runBtn = document.getElementById('cmd_run');
            runBtn.disabled = true;
            runBtn.textContent = 'Running...';
            cmdOutput.textContent = 'Executing command...';
            
            try {
                // Create a new session for this command
                const sessionRes = await fetch('http://localhost:4096/session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: 'Command: ' + command.substring(0, 30) })
                });
                const session = await sessionRes.json();
                cmdSessionId.current = session.id;
                
                // Send the command with structured prompt
                const prompt = `Run this exact command and output ONLY the raw result with no explanation or markdown formatting:\n\n${command}`;
                
                await fetch(`http://localhost:4096/session/${session.id}/message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: prompt })
                });
                
                // Poll for completion
                let attempts = 0;
                const maxAttempts = 60;
                
                const pollInterval = setInterval(async () => {
                    attempts++;
                    
                    try {
                        const statusRes = await fetch(`http://localhost:4096/session/${session.id}`);
                        const statusData = await statusRes.json();
                        
                        if (statusData.status === 'idle' || attempts >= maxAttempts) {
                            clearInterval(pollInterval);
                            
                            // Get messages
                            const msgRes = await fetch(`http://localhost:4096/session/${session.id}/message`);
                            const messages = await msgRes.json();
                            
                            // Find the assistant's response
                            const assistantMsg = messages.filter(m => m.role === 'assistant').pop();
                            if (assistantMsg && assistantMsg.content) {
                                // Extract text content
                                let output = '';
                                for (const part of assistantMsg.content) {
                                    if (part.type === 'text') {
                                        output += part.text;
                                    } else if (part.type === 'tool_use' && part.name === 'bash') {
                                        // Show bash command that was run
                                        output += `$ ${part.input?.command || ''}\n`;
                                    } else if (part.type === 'tool_result') {
                                        output += part.content + '\n';
                                    }
                                }
                                cmdOutput.textContent = output.trim() || 'Command completed (no output)';
                            } else {
                                cmdOutput.textContent = 'No response received';
                            }
                            
                            runBtn.disabled = false;
                            runBtn.textContent = 'Run';
                        }
                    } catch (pollErr) {
                        console.error('Poll error:', pollErr);
                    }
                }, 500);
                
            } catch (err) {
                console.error('Command failed:', err);
                cmdOutput.textContent = 'Error: ' + err.message;
                runBtn.disabled = false;
                runBtn.textContent = 'Run';
            }
        }
        
        function copyOutput() {
            const text = cmdOutput.textContent;
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('cmd_copy');
                const orig = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => { btn.textContent = orig; }, 1000);
            }).catch(err => {
                console.error('Copy failed:', err);
            });
        }

        // Button handlers
        retryBtn.addEventListener('click', retryNow);
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        ctrlAltDelBtn.addEventListener('click', sendCtrlAltDel);
        document.getElementById('screenshot_btn').addEventListener('click', takeScreenshot);
        document.getElementById('record_btn').addEventListener('click', toggleRecording);
        document.getElementById('alttab_btn').addEventListener('click', sendAltTab);
        document.getElementById('super_btn').addEventListener('click', sendSuper);
        document.getElementById('cmd_btn').addEventListener('click', openCmdModal);
        document.getElementById('cmd_close').addEventListener('click', closeCmdModal);
        document.getElementById('cmd_run').addEventListener('click', runCommand);
        document.getElementById('cmd_copy').addEventListener('click', copyOutput);
        cmdInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') runCommand();
            if (e.key === 'Escape') closeCmdModal();
        });

        // Keyboard shortcut: F11 for fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFullscreen();
            }
        });

        // Start connection
        showOverlay('Connecting', 'Establishing connection to VibeOS...');
        connect();
    </script>
</head>

<body>
    <div id="top_bar">
        <div id="logo">V</div>
        <div id="title">VIBEOS</div>
        <div id="spacer"></div>
        <div id="status">
            <span id="status_dot" class="connecting"></span>
            <span id="status_text">Connecting...</span>
        </div>
        <div id="buttons">
            <button class="toolbar_btn" id="screenshot_btn" title="Save screenshot">Screenshot</button>
            <button class="toolbar_btn" id="record_btn" title="Start/stop screen recording">Record</button>
            <button class="toolbar_btn" id="alttab_btn" title="Send Alt+Tab">Alt+Tab</button>
            <button class="toolbar_btn" id="super_btn" title="Send Super/Windows key">Super</button>
            <button class="toolbar_btn" id="cmd_btn" title="Run a command">Run Cmd</button>
            <button class="toolbar_btn" id="fullscreen_btn" title="Fullscreen (F11)">Fullscreen</button>
            <button class="toolbar_btn" id="cad_btn" title="Send Ctrl+Alt+Delete">Ctrl+Alt+Del</button>
        </div>
    </div>

    <div id="screen"></div>

    <div id="reconnect_overlay">
        <div class="overlay_content">
            <div class="overlay_logo">V</div>
            <div id="overlay_status" class="overlay_status">Connecting</div>
            <div id="overlay_message" class="overlay_message">Establishing connection...</div>
            <div class="spinner">
                <div class="spinner_dot"></div>
                <div class="spinner_dot"></div>
                <div class="spinner_dot"></div>
            </div>
            <button class="overlay_btn" id="retry_btn">Retry Now</button>
        </div>
    </div>

    <div id="cmd_modal" class="modal hidden">
        <div class="modal_content">
            <div class="modal_header">
                <span>Run Command</span>
                <button class="modal_close" id="cmd_close">&times;</button>
            </div>
            <div class="modal_body">
                <input type="text" id="cmd_input" placeholder="Enter command (e.g., ls -la, htop, window-list.sh)" autocomplete="off">
                <button class="modal_btn" id="cmd_run">Run</button>
            </div>
            <div class="modal_output_wrapper">
                <pre id="cmd_output"></pre>
                <button class="modal_copy" id="cmd_copy" title="Copy to clipboard">Copy</button>
            </div>
        </div>
    </div>
</body>
</html>
